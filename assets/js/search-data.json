{
  
    
        "post0": {
            "title": "Guide to NumPy For Scientific Computing",
            "content": "This post assumes that you have the necessary skills to work with Python. If you are new to Python, I would highly encourage you to go through Google’s Python Class first. It’s an excellent place for beginners and also offers exercises to get your hands dirty. . Python is a great general-purpose programming language, but it becomes really convenient and powerful for Machine Learning and Data Science with a few popular libraries. The libraries provide efficient code optimization and memory management, along with some additional features and functionalities. . Jupyter notebooks are used for demonstrating the code examples. It is an interactive notebook that lets you run live code, equations, visualizations, and text. You can learn about this at jupyter.org . Introduction . Although all the computations can be done by Python on its own stand-alone, these libraries provide a much efficient way of doing the computations. . Let’s go through an example to understand the importance of these libraries. . Create a list of numbers from 1 to 5 and multiply the elements by 2: . l = [1, 2, 3, 4, 5] print(l) res = l * 2 print(res) # Notice something different . [1, 2, 3, 4, 5] [1, 2, 3, 4, 5, 1, 2, 3, 4, 5] . Multiplying the list by x concatenates the elements of the list x times. We’ll have to write a function for multiplying the elements of the list by 2. . def multiply_2(arr): &quot;&quot;&quot; Multiply elements of list by 2 Parameters: arr - list Input list &quot;&quot;&quot; for i in range(len(arr)): arr[i] = arr[i] * 2 return arr res = multiply_2(l) print(res) . [2, 4, 6, 8, 10] . What’s the problem with the above computation? . This seems fine if we are working on data in smaller quantities, but we work with data in larger quantities, this approach becomes really inefficient. This is where these powerful libraries come in to aid us. . Don’t worry if you don’t get the syntax initially; you’ll get it as we progress through the post. . import numpy as np . a = np.array([1, 2, 3, 4, 5]) print(a) res = a * 2 print(res) . [1 2 3 4 5] [ 2 4 6 8 10] . This library uses a vectorized approach, which simply means applying the operations on whole arrays instead of individual elements. This vectorized code is highly optimized and written in C. . %%timeit multiply_2(l) . The slowest run took 4.88 times longer than the fastest. This could mean that an intermediate result is being cached. 77.5 µs ± 33 µs per loop (mean ± std. dev. of 7 runs, 100000 loops each) . %%timeit a * 2 . 995 ns ± 292 ns per loop (mean ± std. dev. of 7 runs, 1000000 loops each) . The time of execution when using these libraries is really short compared to regular python. There are many more reasons that drive us towards the usage of these libraries. But let’s get started with the usage of these libraries: . NumPy . Numpy is the core library for doing scientific computing in Python involves working the multidimensional arrays. Many libraries are built on top of NumPy. . Basics . A NumPy array is a grid of values, all of the same type. Nested python lists can be used to initialize the array. You can access elements with square brackets for the 1D array, but for the 2D array, it’s a little different. . import numpy as np . a = np.array([1, 2, 3, 4]) print(a) # Create a 2D array b = np.array([[1, 2], [3, 4]]) print(b) . [1 2 3 4] [[1 2] [3 4]] . Let’s write a function which gives us more details of these NumPy arrays: . def print_info(arr): &quot;&quot;&quot; Prints details of the numpy array Parameters: arr - nd array Input array &quot;&quot;&quot; print(&#39;number of elements:&#39;, arr.size) print(&#39;number of dimensions:&#39;, arr.ndim) print(&#39;shape:&#39;, arr.shape) print(&#39;data type:&#39;, arr.dtype) print(&#39;strides:&#39;, arr.strides) print(&#39;flags:&#39;, arr.flags) . ndarray.size: Tells us about the number of elements in a NumPy array. | ndarray.ndim: Tells us about the number of dimensions in a NumPy array. | ndarray.shape: Tells us about the size of the NumPy array along each dimension. | ndarray.dtype: Tells us about the data type of elements in a NumPy array. | ndarray.strides: Tells us about the no. of bytes need to step in each dimension to access the adjacent element. Strides will be multiples of 8 along each dimension. | ndarray.flags: Tells us about how the NumPy array is stored in memory. C_CONTIGUOUS tells us that elements in the memory are row-wise. F_CONTIGUOUS tells us that elements in the memory are column-wise. | . print_info(a) . number of elements: 4 number of dimensions: 1 shape: (4,) data type: int64 strides: (8,) flags: C_CONTIGUOUS : True F_CONTIGUOUS : True OWNDATA : True WRITEABLE : True ALIGNED : True WRITEBACKIFCOPY : False UPDATEIFCOPY : False . print_info(b) . number of elements: 4 number of dimensions: 2 shape: (2, 2) data type: int64 strides: (16, 8) flags: C_CONTIGUOUS : True F_CONTIGUOUS : False OWNDATA : True WRITEABLE : True ALIGNED : True WRITEBACKIFCOPY : False UPDATEIFCOPY : False . Numpy arrays are referenced based. They point to the same array in memory when you assign a defined array to another variable. So you should be careful that you don’t modify the information in place, which may be useful for later purposes. . a = np.array([0, 1, 2, 3, 4]) print(&#39;a:&#39;, a) b = a a[0] = 5 print(&#39;b:&#39;, b) a[0] = 0 . a: [0 1 2 3 4] b: [5 1 2 3 4] . Numpy provides a copy method to create a copy of the same array in memory. . print(&#39;a:&#39;, a) b = a.copy() a[0] = 5 print(&#39;b:&#39;, b) . a: [0 1 2 3 4] b: [0 1 2 3 4] . Numpy also provides many functions to create arrays. Most of the functions take shape as a parameter. . a = np.ones((1, 3)) print(&#39;a:&#39;, a) # Create an array of all zeros b = np.zeros((1, 3)) print(&#39;b:&#39;, b) # Create a constant array c = np.full((1, 3), 4) print(&#39;c:&#39;, c) # Create an identity matrix of 3x3 d = np.eye(3) print(&#39;d:&#39;, d) # Create an array of random values e = np.random.random((1, 3)) print(&#39;e:&#39;, e) # Create an array of random values from uniform distribution f = np.random.rand(3) print(&#39;f:&#39;, f) # Create an array of random values from normal distribution g = np.random.randn(3) print(&#39;g:&#39;, g) . a: [[1. 1. 1.]] b: [[0. 0. 0.]] c: [[4 4 4]] d: [[1. 0. 0.] [0. 1. 0.] [0. 0. 1.]] e: [[0.22551855 0.18974127 0.87953329]] f: [0.54819848 0.01511915 0.5365319 ] g: [-0.87897997 -1.95487666 0.62275 ] . Numpy array provides different numeric datatypes options to construct the arrays. This can be really useful when you have a large dataset, so you can set the datatype based on the data limits to be memory efficient. . a = np.array([[1, 0], [0, 1]]) print(&#39;Datatype of a:&#39;, a.dtype) b = np.array([[1.0, 0], [0, 1.0]]) print(&#39;Datatype of b:&#39;, b.dtype) # Explicitly specify the datatype c = np.array([[1, 0], [0, 1]], dtype=np.int32) print(&#39;Datatype of c:&#39;, c.dtype) d = np.array([[1.0, 0], [0, 1.0]], dtype=np.float32) print(&#39;Datatype of d:&#39;, d.dtype) . Datatype of a: int64 Datatype of b: float64 Datatype of c: int32 Datatype of d: float32 . Slicing . Although slicing is similar to Python lists, there’s a slight difference for multi-dimensional arrays. We need to specify the slice for each dimension of the array. . Let’s walk through some examples to get a better understanding: . a = np.array([[0, 1, 2, 3], [4, 5, 6, 7], [8, 9, 10, 11], [12, 13, 14, 15]]) print(a) . [[ 0 1 2 3] [ 4 5 6 7] [ 8 9 10 11] [12 13 14 15]] . a[:2, :] # same as a[:2] . array([[0, 1, 2, 3], [4, 5, 6, 7]]) . a[:2, :2] . array([[0, 1], [4, 5]]) . a[::2, ::2] . array([[ 0, 2], [ 8, 10]]) . Now try slicing the four center elements of the array: . a[1:3, 1:3] . array([[ 5, 6], [ 9, 10]]) . a[[1, 1, 2, 2], [1, 2, 1, 2]] . array([ 5, 6, 9, 10]) . Now try accessing the elements 1, 2, 4, 7 of the array such that the dimension is not reduced: . a[[[0, 0], [1, 1]], [[1, 2], [0, 3]]] . array([[1, 2], [4, 7]]) . a[[[0], [1]], [[1, 2], [0, 3]]] . array([[1, 2], [4, 7]]) . Note that the alternative way uses broadcasting, which will be discussed later in the post. Things will be much clearer there, so please have a bit of patience. . Functions and Aggregations . Numpy comes with a lot of built-in functions, which are useful for performing various computations efficiently. One can perform arithmetic, matrix, trigonometric, exponent, logarithm operations, and many more. . Let&#39;s go through a few of these operations: . a = np.array([[0, 1], [2, 3]]) print(&#39;a:&#39;, a) b = np.ones((2, 2)) print(&#39;b:&#39;, b) . a: [[0 1] [2 3]] b: [[1. 1.] [1. 1.]] . Arithmetic Operations . print(&#39;a + b =&#39;, np.add(a, b)) # same as print(a + b) # Elementwise difference print(&#39;a - b =&#39;, np.subtract(a, b)) # same as print(a - b) # Elementwise product print(&#39;a * b =&#39;, np.multiply(a, b)) # same as print(a * b) # Elementwise division print(&#39;a / b =&#39;, np.divide(a, b)) # same as print(a / b) # Elementwise modulo print(&#39;a % b =&#39;, np.mod(a, b)) # same as print(a % b) . a + b = [[1. 2.] [3. 4.]] a - b = [[-1. 0.] [ 1. 2.]] a * b = [[0. 1.] [2. 3.]] a / b = [[0. 1.] [2. 3.]] a % b = [[0. 0.] [0. 0.]] . a = np.array([[0, -1, 2], [-3, 4, -5], [6, -7, 8]]) # Absolute values print(&#39;|a| =&#39;, np.abs(a)) # same as print(np.absolute(a)) # Square values print(&#39;a ^ 2 =&#39;, np.square(a)) # same as print(a ** 2) # Square root values print(&#39;a ^ 0.5 =&#39;, np.sqrt(np.abs(a))) # same as print(np.abs(a) ** 0.5) . |a| = [[0 1 2] [3 4 5] [6 7 8]] a ^ 2 = [[ 0 1 4] [ 9 16 25] [36 49 64]] a ^ 0.5 = [[0. 1. 1.41421356] [1.73205081 2. 2.23606798] [2.44948974 2.64575131 2.82842712]] . Matrix Operations . a = np.array([[0, 1], [2, 3]]) # Create a matrix of shape (2,) b = np.array([2, 4]) # Dot product of vector / vector print(&#39;b x b =&#39;, np.dot(b, b)) # same as print(b.dot(b)) # Product of matrix / vector print(&#39;a x b =&#39;, np.dot(a, b)) # same as print(a.dot(b)) # Product of matrix / matrix print(&#39;a x a =&#39;, np.dot(a, a)) # same as print(a.dot(a)) . b x b = 20 a x b = [ 4 16] a x a = [[ 2 3] [ 6 11]] . Trigonometric Operations . theta = np.linspace(0, np.pi, 3) print(&#39;theta =&#39;, theta) print(&#39;sin(theta) =&#39;, np.sin(theta)) print(&#39;cos(theta) =&#39;, np.cos(theta)) print(&#39;tan(theta) =&#39;, np.tan(theta)) . theta = [0. 1.57079633 3.14159265] sin(theta) = [0.0000000e+00 1.0000000e+00 1.2246468e-16] cos(theta) = [ 1.000000e+00 6.123234e-17 -1.000000e+00] tan(theta) = [ 0.00000000e+00 1.63312394e+16 -1.22464680e-16] . x = np.array([-1, 0, 1]) print(&quot;x =&quot;, x) print(&quot;arcsin(x) =&quot;, np.arcsin(x)) print(&quot;arccos(x) =&quot;, np.arccos(x)) print(&quot;arctan(x) =&quot;, np.arctan(x)) . x = [-1 0 1] arcsin(x) = [-1.57079633 0. 1.57079633] arccos(x) = [3.14159265 1.57079633 0. ] arctan(x) = [-0.78539816 0. 0.78539816] . Exponentiation Operations . a = np.arange(1, 5) print(&#39;a =&#39;, a) print(&#39;e ^ a =&#39;, np.exp(a)) print(&#39;e ^ a - 1 =&#39;, np.expm1(a)) print(&#39;2 ^ a =&#39;, np.exp2(a)) print(&#39;10 ^ a =&#39;, np.power(10, a)) . a = [1 2 3 4] e ^ a = [ 2.71828183 7.3890561 20.08553692 54.59815003] e ^ a - 1 = [ 1.71828183 6.3890561 19.08553692 53.59815003] 2 ^ a = [ 2. 4. 8. 16.] 10 ^ a = [ 10 100 1000 10000] . Logarithmic Operations . a = np.arange(1, 5) print(&#39;a =&#39;, a) print(&#39;ln(a) =&#39;, np.log(a)) print(&#39;ln(a + 1) =&#39;, np.log1p(a)) print(&#39;log2(a) =&#39;, np.log2(a)) print(&#39;log10(a) =&#39;, np.log10(a)) . a = [1 2 3 4] ln(a) = [0. 0.69314718 1.09861229 1.38629436] ln(a + 1) = [0.69314718 1.09861229 1.38629436 1.60943791] log2(a) = [0. 1. 1.5849625 2. ] log10(a) = [0. 0.30103 0.47712125 0.60205999] . Aggregates . a = np.arange(1, 5) print(a) . [1 2 3 4] . Calling the reduce method on arithmetic functions like add returns the sum of all elements in the array. Similarly, calling the accumulate method on arithmetic functions like add returns the array of intermediate results: . print(np.add.reduce(a)) # Product of all elements of array print(np.multiply.reduce(a)) # Intermediate result of sum print(np.add.accumulate(a)) # Intermediate result of product print(np.multiply.accumulate(a)) . 10 24 [ 1 3 6 10] [ 1 2 6 24] . a = np.random.rand(2, 2) print(a) . [[0.68347343 0.56920798] [0.20602274 0.92199748]] . print(np.sum(a)) # same as print(a.sum()) # Minimum value of array print(np.min(a)) # same as print(a.min()) # Maximum value of array print(np.max(a)) # same as print(a.max()) . 2.380701625644927 0.2060227376885182 0.9219974808291727 . We can find the sum, min, and max row-wise or col-wise by specifying the axis argument. . axis = 0 specifies we are reducing rows that means we are finding row-wise . | axis = 1 specifies we are reducing cols that means we are finding col-wise . | . print(np.sum(a, axis=0)) # same as print(a.sum(axis=0)) # Min value of array row wise print(np.min(a, axis=0)) # same as print(a.min(axis=0)) # Max value of array row wise print(np.max(a, axis=0)) # same as print(a.max(axis=0)) . [0.88949617 1.49120546] [0.20602274 0.56920798] [0.68347343 0.92199748] . print(np.sum(a, axis=1)) # same as print(a.sum(axis=1)) # Min value of array col wise print(np.min(a, axis=1)) # same as print(a.min(axis=1)) # Max value of array col wise print(np.max(a, axis=1)) # same as print(a.max(axis=1)) . [1.25268141 1.12802022] [0.56920798 0.20602274] [0.68347343 0.92199748] . print(np.argmin(a)) print(np.argmax(a)) . 2 3 . print(np.argmin(a, axis=0)) print(np.argmax(a, axis=0)) . [1 0] [0 1] . print(np.argmin(a, axis=1)) print(np.argmax(a, axis=1)) . [1 0] [0 1] . There are various other functions such as np.mean, np.std, np.median, np.percentile, np.any, np.all which you can refer in the documentation. . Broadcasting . Broadcasting is a way that allows us to work with NumPy arrays of different shapes when performing arithmetic operations. . Rules of Broadcasting: . Array with fewer dimensions is padded with ones on the leading side | If the shape of two arrays do not match in any dimension, the array with a shape equal to 1 is stretched to match the other shape | If in any dimension the sizes disagree and neither equal to 1, then the array is not compatible, thus leading to an error. | . a = np.arange(0, 4) print(a) . [0 1 2 3] . a + 4 . array([4, 5, 6, 7]) . In the above example, there is a duplication of the scalar value 4 into the array of shape same as an array a and performs addition, which can be demonstrated in the below figure: . . a = np.arange(0, 4) print(&#39;a:&#39;, a) # Create an array of shape (4, 1) b = np.arange(0, 4).reshape(4, 1) print(&#39;b:&#39;, b) . a: [0 1 2 3] b: [[0] [1] [2] [3]] . a + b . array([[0, 1, 2, 3], [1, 2, 3, 4], [2, 3, 4, 5], [3, 4, 5, 6]]) . In the above example, a and b both stretches row-wise and col-wise respectively, which can be demonstrated in the below figure: . . a = np.arange(1, 7).reshape(3, 2) # Create an array of shape (2,) b = np.ones((2,)) . a + b . array([[2., 3.], [4., 5.], [6., 7.]]) . In the above example, broadcasting takes for the b, which is demonstrated in the below figure: . . a = np.arange(1, 7).reshape(3, 2) # Create an array of shape (3,) b = np.ones((3,)) . a + b . ValueError Traceback (most recent call last) &lt;ipython-input-48-bd58363a63fc&gt; in &lt;module&gt; -&gt; 1 a + b ValueError: operands could not be broadcast together with shapes (3,2) (3,) . In the above example, broadcasting does not take place as the shapes are incompatible, which can be demonstrated in the below figure: . . Fancy Indexing . Fancy indexing is simply accessing multiple elements of an array at once through the use of an array of indices. It&#39;s slicing in simple ways. . Let&#39;s walk through a few examples to understand the above: . a = np.random.randint(10, size=(3, 3)) print(a) . [[4 0 1] [5 2 8] [9 8 3]] . row = np.array([0, 1, 2]) col = np.array([1, 0, 2]) a[row, col] . array([0, 5, 3]) . a[1:, col] . array([[2, 5, 8], [8, 9, 3]]) . In the above example, broadcasting is used for the row indices. . a = np.random.randint(50, size=10) print(a) . [20 21 29 30 28 12 10 3 38 1] . mask = a &gt; 25 print(mask) . [False False True True True False False False True False] . Mask means boolean indexing where the True value indicates that the element at a particular index satisfies the conditions. This mask array helps us filtering the elements, and we can access the elements from the array using the mask as an array of indices. . print(a[mask]) . [29 30 28 38] . This masking can also be useful for modifying the values of arrays that do not satisfy the constraints. Let&#39;s see an example: . a = np.random.randint(-10, 10, size=(10,)) print(a) . [ 6 4 9 9 -7 3 -8 9 5 -3] . neg_mask = a &lt; 0 print(a[neg_mask]) . [-7 -8 -3] . a[neg_mask] = 0 print(a) . [6 4 9 9 0 3 0 9 5 0] . Strides . Computer Memory is a single tape where we need to travel sequentially in order to access the data. Strides specify the number of bytes we need to travel in the memory to access the adjacent element along each dimension. Numpy arrays are stored in a contiguous block of memory, so strides become really handy. Strides are multiples of 8 and by default row-major. . a = np.random.random((3, 2)) print(a) . [[0.07495098 0.03693228] [0.48777201 0.60112812] [0.47782039 0.18343593]] . print_info(a) . number of elements: 6 number of dimensions: 2 shape: (3, 2) data type: float64 strides: (16, 8) flags: C_CONTIGUOUS : True F_CONTIGUOUS : False OWNDATA : True WRITEABLE : True ALIGNED : True WRITEBACKIFCOPY : False UPDATEIFCOPY : False . strides: (16, 8) indicates that we need to travel 16 bytes to get the adjacent element row-wise and 8 bytes to get the adjacent element col-wise. . a_T = a.T print(a_T) . [[0.07495098 0.48777201 0.47782039] [0.03693228 0.60112812 0.18343593]] . print_info(a_T) . number of elements: 6 number of dimensions: 2 shape: (2, 3) data type: float64 strides: (8, 16) flags: C_CONTIGUOUS : False F_CONTIGUOUS : True OWNDATA : False WRITEABLE : True ALIGNED : True WRITEBACKIFCOPY : False UPDATEIFCOPY : False . If you notice the strides have been reversed from (16, 8) to (8, 16), which tells us that this is just the view of array `a’. This is the reason why NumPy is memory efficient as it points to the memory instead of creating another array as compared to python. . Note that the F_CONTIGUOUS: True which means the array a_T is column-major. . np.reshape is also based on the idea of strides, which returns the view of the same array with modified strides: . b = a.reshape(6,) print(b) . [0.07495098 0.03693228 0.48777201 0.60112812 0.47782039 0.18343593] . print_info(b) . number of elements: 6 number of dimensions: 1 shape: (6,) data type: float64 strides: (8,) flags: C_CONTIGUOUS : True F_CONTIGUOUS : True OWNDATA : False WRITEABLE : True ALIGNED : True WRITEBACKIFCOPY : False UPDATEIFCOPY : False . Broadcasting also uses the concept of strides when performing arithmetic operations. Let’s see an example: . a = np.random.random((3, 2)) print(a) # Create an array of shape (10,) b = np.random.randint(10, size=4) print(b) . [[0.76096701 0.23538774] [0.31361445 0.58805459] [0.91557476 0.24585326]] [9 0 8 2] . c = a + b . ValueError Traceback (most recent call last) &lt;ipython-input-65-1674f6151070&gt; in &lt;module&gt; -&gt; 1 c = a + b ValueError: operands could not be broadcast together with shapes (3,2) (4,) . Broadcasting, by default, gives us an error as the above operation does not satisfy broadcasting rules. Let’s apply some modifications, so it satisfies the broadcasting rules, and we get the array of shape (4, 3, 2): . c = a + b[:, np.newaxis, np.newaxis] print_info(c) . number of elements: 24 number of dimensions: 3 shape: (4, 3, 2) data type: float64 strides: (48, 16, 8) flags: C_CONTIGUOUS : True F_CONTIGUOUS : False OWNDATA : True WRITEABLE : True ALIGNED : True WRITEBACKIFCOPY : False UPDATEIFCOPY : False . np.broadcast_arrays returns the broadcasted arrays of the same shape that NumPy adds together in the above code block. . a_broadcast, b_broadcast = np.broadcast_arrays(a, b[:, np.newaxis, np.newaxis]) . print_info(a_broadcast) . number of elements: 24 number of dimensions: 3 shape: (4, 3, 2) data type: float64 strides: (0, 16, 8) flags: C_CONTIGUOUS : False F_CONTIGUOUS : False OWNDATA : False WRITEABLE : True (with WARN_ON_WRITE=True) ALIGNED : True WRITEBACKIFCOPY : False UPDATEIFCOPY : False . print(a_broadcast) . [[[0.76096701 0.23538774] [0.31361445 0.58805459] [0.91557476 0.24585326]] [[0.76096701 0.23538774] [0.31361445 0.58805459] [0.91557476 0.24585326]] [[0.76096701 0.23538774] [0.31361445 0.58805459] [0.91557476 0.24585326]] [[0.76096701 0.23538774] [0.31361445 0.58805459] [0.91557476 0.24585326]]] . strides: (0, 16, 8) indicates that the virtual view of the array a in which the view of the array appears as many times as the leading shape. In the above case, it is 4 times. . print_info(b_broadcast) . number of elements: 24 number of dimensions: 3 shape: (4, 3, 2) data type: int64 strides: (8, 0, 0) flags: C_CONTIGUOUS : False F_CONTIGUOUS : False OWNDATA : False WRITEABLE : True (with WARN_ON_WRITE=True) ALIGNED : True WRITEBACKIFCOPY : False UPDATEIFCOPY : False . print(b_broadcast) . [[[9 9] [9 9] [9 9]] [[0 0] [0 0] [0 0]] [[8 8] [8 8] [8 8]] [[2 2] [2 2] [2 2]]] . strides: (8, 0, 0) indicates that the virtual array consists of every element of array b, which appears as a 2D array of shape (3, 2) . How can we manipulate the strides and shape of an array to produce a virtual array that is much bigger but using the same memory? . def repeat(arr, n): &quot;&quot;&quot; Produce a virtual array which is n times bigger than arr without extra memory usage Parameters: arr - nd array Input array n - int Size of repeated array &quot;&quot;&quot; return np.lib.stride_tricks.as_strided(arr, shape=(n,) + arr.shape, strides=(0,) + arr.strides) . repeat(np.random.random(4), 3) . array([[0.27505351, 0.06159749, 0.03617048, 0.33832092], [0.27505351, 0.06159749, 0.03617048, 0.33832092], [0.27505351, 0.06159749, 0.03617048, 0.33832092]]) . Exercises . Create a 2D array with 1 on the border and 0 inside. . X = np.ones((5, 5)) X[1:-1, 1:-1] = 0 # Alternative way using np.zeros X = np.zeros((5, 5)) X[:, [0, -1]] = 1 X[[0, -1], 1:-1] = 1 . Normalize a 5 x 5 random matrix. . X = np.random.random((5, 5)) X_mean = np.mean(X) X_std = np.std(X) X_norm = (X - X_mean) / X_std . Given a 1D array, negate all elements which are between 3 and 8 inclusive, in place. . X = np.arange(11) mask = (2 &lt; X) &amp; (X &lt; 9) X[mask] *= -1 . How to get the alternates dates corresponding to the month of July 2016? . X = np.arange(&#39;2016-07&#39;, &#39;2016-08&#39;, 2, dtype=&#39;datetime64[D]&#39;) . Create a vector of size 10 with values ranging from 0 to 1, both excluded. . X = np.linspace(0, 1, 12)[1:-1] # Alternative way X = np.linspace(0, 1, 11, endpoint=False)[1:] . How to sort an array by the nth column? . X = np.random.randint(0, 10, (4, 3)) nth_col_sort_idx = X[:, -1].argsort() X_sort = X[nth_col_sort_idx] . Find the nearest value from a given value in an array. . X = np.random.rand(10) val = 0.75 nearest = X[np.abs(X - val).argmin()] . How to accumulate elements of a vector (X) to an array (F) based on an index list (I)? . X = np.random.randint(10, size=5) I = np.random.randint(10, size=5) F = np.bincount(I, X) . Considering a four dimensions array, how to get sum over the last two axis at once? . X = np.random.random((4, 4, 4, 4)) # Flatten the two dimensions into one new_shape = X.shape[:-2] + (-1,) Y = X.reshape(new_shape).sum(axis=-1) # Alternative way # X = np.random.random((4, 4, 4, 4)) # Tuple of axis (supported for numpy 1.7.0 onwards) # Y = X.sum(axis=(-2, -1)) . Create a function to produce a sliding window view of a 1D array. . def sliding_window(arr, size=2): &quot;&quot;&quot; Produce an array of sliding window views of arr Parameters: arr - nd array Input array size - int, optional Size of sliding window &quot;&quot;&quot; N = arr.shape[0] s = arr.strides[0] return np.lib.stride_tricks.as_strided(arr, shape=(N - size + 1, size), strides=(s, s)) . Future Resources . So far, we’ve covered many of the basics of using NumPy for performing scientific computing. But there’s still a lot of material that you can learn from. To learn more about Numpy, I would definitely recommend the following: . Pandas Data Science Handbook covers much more about Numpy. But it also has other libraries such as Pandas, Matplotlib very well explained with code walkthrough. | Advanced NumPy - SciPy 2019 covers a lot of advanced material that we have not touched on in this post. | Scipy Lecture Notes is a good resource for learning libraries related to scientific computing such as NumPy, SciPy in Python | 100 NumPy Exercises is a good place to test your knowledge. | . References . Numpy | Introduction to Numerical Computing with NumPy - SciPy 2019 | Advanced NumPy - SciPy 2019 | Python Data Science Handbook | 100 NumPy Exercises | .",
            "url": "https://jaygala24.github.io/blog/python/numpy/2020/06/20/guide-to-numpy.html",
            "relUrl": "/python/numpy/2020/06/20/guide-to-numpy.html",
            "date": " • Jun 20, 2020"
        }
        
    
  
    
        ,"post1": {
            "title": "Fastpages Notebook Blog Post",
            "content": "About . This notebook is a demonstration of some of capabilities of fastpages with notebooks. . With fastpages you can save your jupyter notebooks into the _notebooks folder at the root of your repository, and they will be automatically be converted to Jekyll compliant blog posts! . Front Matter . The first cell in your Jupyter Notebook or markdown blog post contains front matter. Front matter is metadata that can turn on/off options in your Notebook. It is formatted like this: . # &quot;My Title&quot; &gt; &quot;Awesome summary&quot; - toc:true- branch: master - badges: true - comments: true - author: Hamel Husain &amp; Jeremy Howard - categories: [fastpages, jupyter] . Setting toc: true will automatically generate a table of contents | Setting badges: true will automatically include GitHub and Google Colab links to your notebook. | Setting comments: true will enable commenting on your blog post, powered by utterances. | . The title and description need to be enclosed in double quotes only if they include special characters such as a colon. More details and options for front matter can be viewed on the front matter section of the README. . Markdown Shortcuts . A #hide comment at the top of any code cell will hide both the input and output of that cell in your blog post. . A #hide_input comment at the top of any code cell will only hide the input of that cell. . The comment #hide_input was used to hide the code that produced this. . put a #collapse-hide flag at the top of any cell if you want to hide that cell by default, but give the reader the option to show it: . import pandas as pd import altair as alt . . put a #collapse-show flag at the top of any cell if you want to show that cell by default, but give the reader the option to hide it: . cars = &#39;https://vega.github.io/vega-datasets/data/cars.json&#39; movies = &#39;https://vega.github.io/vega-datasets/data/movies.json&#39; sp500 = &#39;https://vega.github.io/vega-datasets/data/sp500.csv&#39; stocks = &#39;https://vega.github.io/vega-datasets/data/stocks.csv&#39; flights = &#39;https://vega.github.io/vega-datasets/data/flights-5k.json&#39; . . place a #collapse-output flag at the top of any cell if you want to put the output under a collapsable element that is closed by default, but give the reader the option to open it: . print(&#39;The comment #collapse-output was used to collapse the output of this cell by default but you can expand it.&#39;) . The comment #collapse-output was used to collapse the output of this cell by default but you can expand it. . . Interactive Charts With Altair . Charts made with Altair remain interactive. Example charts taken from this repo, specifically this notebook. . Example 1: DropDown . # use specific hard-wired values as the initial selected values selection = alt.selection_single( name=&#39;Select&#39;, fields=[&#39;Major_Genre&#39;, &#39;MPAA_Rating&#39;], init={&#39;Major_Genre&#39;: &#39;Drama&#39;, &#39;MPAA_Rating&#39;: &#39;R&#39;}, bind={&#39;Major_Genre&#39;: alt.binding_select(options=genres), &#39;MPAA_Rating&#39;: alt.binding_radio(options=mpaa)} ) # scatter plot, modify opacity based on selection alt.Chart(df).mark_circle().add_selection( selection ).encode( x=&#39;Rotten_Tomatoes_Rating:Q&#39;, y=&#39;IMDB_Rating:Q&#39;, tooltip=&#39;Title:N&#39;, opacity=alt.condition(selection, alt.value(0.75), alt.value(0.05)) ) . Example 2: Tooltips . alt.Chart(df).mark_circle().add_selection( alt.selection_interval(bind=&#39;scales&#39;, encodings=[&#39;x&#39;]) ).encode( alt.X(&#39;Rotten_Tomatoes_Rating&#39;, type=&#39;quantitative&#39;), alt.Y(&#39;IMDB_Rating&#39;, type=&#39;quantitative&#39;, axis=alt.Axis(minExtent=30)), # y=alt.Y(&#39;IMDB_Rating:Q&#39;, ), # use min extent to stabilize axis title placement tooltip=[&#39;Title:N&#39;, &#39;Release_Date:N&#39;, &#39;IMDB_Rating:Q&#39;, &#39;Rotten_Tomatoes_Rating:Q&#39;] ).properties( width=500, height=400 ) . Example 3: More Tooltips . label = alt.selection_single( encodings=[&#39;x&#39;], # limit selection to x-axis value on=&#39;mouseover&#39;, # select on mouseover events nearest=True, # select data point nearest the cursor empty=&#39;none&#39; # empty selection includes no data points ) # define our base line chart of stock prices base = alt.Chart().mark_line().encode( alt.X(&#39;date:T&#39;), alt.Y(&#39;price:Q&#39;, scale=alt.Scale(type=&#39;log&#39;)), alt.Color(&#39;symbol:N&#39;) ) alt.layer( base, # base line chart # add a rule mark to serve as a guide line alt.Chart().mark_rule(color=&#39;#aaa&#39;).encode( x=&#39;date:T&#39; ).transform_filter(label), # add circle marks for selected time points, hide unselected points base.mark_circle().encode( opacity=alt.condition(label, alt.value(1), alt.value(0)) ).add_selection(label), # add white stroked text to provide a legible background for labels base.mark_text(align=&#39;left&#39;, dx=5, dy=-5, stroke=&#39;white&#39;, strokeWidth=2).encode( text=&#39;price:Q&#39; ).transform_filter(label), # add text labels for stock prices base.mark_text(align=&#39;left&#39;, dx=5, dy=-5).encode( text=&#39;price:Q&#39; ).transform_filter(label), data=stocks ).properties( width=500, height=400 ) . Data Tables . You can display tables per the usual way in your blog: . df[[&#39;Title&#39;, &#39;Worldwide_Gross&#39;, &#39;Production_Budget&#39;, &#39;Distributor&#39;, &#39;MPAA_Rating&#39;, &#39;IMDB_Rating&#39;, &#39;Rotten_Tomatoes_Rating&#39;]].head() . Title Worldwide_Gross Production_Budget Distributor MPAA_Rating IMDB_Rating Rotten_Tomatoes_Rating . 0 The Land Girls | 146083.0 | 8000000.0 | Gramercy | R | 6.1 | NaN | . 1 First Love, Last Rites | 10876.0 | 300000.0 | Strand | R | 6.9 | NaN | . 2 I Married a Strange Person | 203134.0 | 250000.0 | Lionsgate | None | 6.8 | NaN | . 3 Let&#39;s Talk About Sex | 373615.0 | 300000.0 | Fine Line | None | NaN | 13.0 | . 4 Slam | 1087521.0 | 1000000.0 | Trimark | R | 3.4 | 62.0 | . Images . Local Images . You can reference local images and they will be copied and rendered on your blog automatically. You can include these with the following markdown syntax: . ![](my_icons/fastai_logo.png) . . Remote Images . Remote images can be included with the following markdown syntax: . ![](https://image.flaticon.com/icons/svg/36/36686.svg) . . Animated Gifs . Animated Gifs work, too! . ![](https://upload.wikimedia.org/wikipedia/commons/7/71/ChessPawnSpecialMoves.gif) . . Captions . You can include captions with markdown images like this: . ![](https://www.fast.ai/images/fastai_paper/show_batch.png &quot;Credit: https://www.fast.ai/2020/02/13/fastai-A-Layered-API-for-Deep-Learning/&quot;) . . Other Elements . GitHub Flavored Emojis . Typing I give this post two :+1:! will render this: . I give this post two :+1:! . Tweetcards . Typing &gt; twitter: https://twitter.com/jakevdp/status/1204765621767901185?s=20 will render this: Altair 4.0 is released! https://t.co/PCyrIOTcvvTry it with: pip install -U altairThe full list of changes is at https://t.co/roXmzcsT58 ...read on for some highlights. pic.twitter.com/vWJ0ZveKbZ . &mdash; Jake VanderPlas (@jakevdp) December 11, 2019 . Youtube Videos . Typing &gt; youtube: https://youtu.be/XfoYk_Z5AkI will render this: . Boxes / Callouts . Typing &gt; Warning: There will be no second warning! will render this: . Warning: There will be no second warning! . Typing &gt; Important: Pay attention! It&#39;s important. will render this: . Important: Pay attention! It&#8217;s important. . Typing &gt; Tip: This is my tip. will render this: . Tip: This is my tip. . Typing &gt; Note: Take note of this. will render this: . Note: Take note of this. . Typing &gt; Note: A doc link to [an example website: fast.ai](https://www.fast.ai/) should also work fine. will render in the docs: . Note: A doc link to an example website: fast.ai should also work fine. . Footnotes . You can have footnotes in notebooks, however the syntax is different compared to markdown documents. This guide provides more detail about this syntax, which looks like this: . For example, here is a footnote {% fn 1 %}. And another {% fn 2 %} {{ &#39;This is the footnote.&#39; | fndetail: 1 }} {{ &#39;This is the other footnote. You can even have a [link](www.github.com)!&#39; | fndetail: 2 }} . For example, here is a footnote 1. . And another 2 . 1. This is the footnote.↩ . 2. This is the other footnote. You can even have a link!↩ .",
            "url": "https://jaygala24.github.io/blog/jupyter/2020/02/20/test.html",
            "relUrl": "/jupyter/2020/02/20/test.html",
            "date": " • Feb 20, 2020"
        }
        
    
  

  
  

  
      ,"page1": {
          "title": "About Me",
          "content": "Hi! I’m Jay 👋, a CS undergrad from Mumbai University. I started my programming career with C language in 2017. I have fluency in programming languages like C, Python and JavaScript. I have been working on solving problems using ML for over a year now. . Current areas of interests: . Multimodal dialogue and question answering system | Fairness and bias in language models | Interpretability | . Independent research projects: . Worked on the task of visual dialog with the aim of reducing the bias towards dialog history using mixed attention mechanisms as a part of final year project (Accepted at ICACDS 2021). | Co-authored a paper on using object detection and image processing techniques to estimate the dimension of potholes (Published at IVCNZ 2020). | Co-authored a chapter titled “Combatting COVID-19 using Object Detection Techniques” for Elsevier’s CPS-AI &amp; COVID-19 book (Accepted). | Co-authored papers on using IoT and ML effectively to automate tasks in agriculture and waste management sectors. | . You can find more about the publications on Scholar. . I have previously worked as a ML project intern at Tata Consultancy Services where I got the opportunity to work on understanding customer behavior using NLP. I have also collaborated with Prof. Pratik Kanani on a industry project focusing on anamoly detection in heart rate (pulse) using IoT and ML. I also led a team that developed a platform for conducting C programming examination in the college for over 500 students demo. . I’m also working as a mentor at DJ Unicode an open source organization by our college department where I help juniors on software development projects and as well as learn new stuffs too 😀. . You can reach out to me using Twitter or Linkedin. .",
          "url": "https://jaygala24.github.io/blog/about/",
          "relUrl": "/about/",
          "date": ""
      }
      
  

  

  
  

  

  
  

  

  
  

  
  

  
  

  
      ,"page10": {
          "title": "",
          "content": "Sitemap: {{ “sitemap.xml” | absolute_url }} | .",
          "url": "https://jaygala24.github.io/blog/robots.txt",
          "relUrl": "/robots.txt",
          "date": ""
      }
      
  

}